package ${targetPackage};

<#if withGET>import java.util.List;
import java.util.stream.Collectors;
</#if>
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
<#if hasIdProperty>import ${resourceRepresentation.qualifiedName};
import ${keyProperty.type.qualifiedName}; 
</#if>
/**
 * this class maps ${resourceName} REST operations to
 * the ${targetName} entity.
 * // TODO: replace ${targetName} with the actual target class name.
 */

@RequestScoped
public class Mapped${resourceName}ResourceController implements I${resourceName}ResourceController {

	@Inject
	private I${targetName}Controller targetController;
	
	@Inject
	private ${resourceName}ResourceMapper resourceMapper;
	
	@Inject
	private ${targetName}Mapper targetMapper;
	
	@Inject
	private TransactionRunner runner;

	private <T> T transactional(TransactionRunner.TransactionalBlock<T> blk) {
		return runner.run(blk);
	}
	
	
<#if withPOST && hasIdProperty> 	@Override
	public ${keyPropertyType} create(${resourceRepresentation.name} rro) {
		// convert from the resource to a detached entity
		${targetName} detached = resourceMapper.map(rro);
		
		// call the controller to 'create' the object
		${resourceRepresentation.name} result = transactional( () -> {
			${targetName} managed = targetController.create(detached);
			
			// map the return value to a resource representation
			return targetMapper.map(managed);
		});
		return result.get${keyName?capitalize}();
	}
</#if>
<#if withGET && hasIdProperty> 	@Override
	public ${resourceRepresentation.name} get(${keyPropertyType} ${keyName}) {
		
		${resourceRepresentation.name} result = transactional(() -> {
			${targetName} updated = targetController.findByGuid(guid);
			return targetMapper.map(updated);
		});
		return result;
	}
</#if>
<#if withDELETE  && hasIdProperty> 	@Override
	public void remove(${keyPropertyType} ${keyName}) {
		targetController.remove(${keyName});
	}
</#if>

<#if withPUT && hasIdProperty> 	@Override
	public ${resourceRepresentation.name} update(${keyPropertyType} ${keyName}, ${resourceRepresentation.name} rro) {

		${targetName} detached = resourceMapper.map(rro);

		${resourceRepresentation.name} result = transactional(() -> {
			${targetName} updated = targetController.update(guid, detached);
			return targetMapper.map(updated);
		});
		return result;
	}</#if>
<#if withGET>	// add get methods returning lists to I${resourceName}ResourcesClass
	
 	@Override
	public List<${resourceRepresentation.name}> getAll(Integer startPosition, Integer maxResult) {
		return transactional(() -> {
			return targetController
					.findAll()
					.stream()
					.map((n) -> targetMapper.map(n))
					.collect(Collectors.toList());
		});
	}
</#if>}
